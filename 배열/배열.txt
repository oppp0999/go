배열은 길이가 고정된, 번호가 매겨진 단일 타입 원소의 나열이다. Go에서는 다음과 같은 형태를 띤다.

var x [5]int
x는 5개의 int 타입으로 구성된 배열의 예다. 다음 프로그램을 실행해 보자.

package main
 
import "fmt"
 
func main() {
    var x [5]int
    x[4] = 100
    fmt.Println(x)
}
출력 결과는 다음과 같다.

[0 0 0 0 100]
x[4] = 100은 "배열 x의 5번째 요소를 100으로 설정하라"로 읽으면 된다. 여기서 x[4]가 4번째 요소가 아니라 5번째 요소를 나타내는 것이 이상해 보일 수도 있겠지만 문자열과 마찬가지로 배열도 0부터 인덱스가 시작한다. 배열에도 비슷한 방식으로 접근한다. fmt.Println(x)를 fmt.Println(x[4])로 수정하면 100이 출력될 것이다.

다음은 배열을 사용하는 프로그램의 예다.


func main() {

    var x [5]float64
    x[0] = 98
    x[1] = 93
    x[2] = 77
    x[3] = 82
    x[4] = 83
 
    var total float64 = 0
    for i := 0; i < 5; i++ {
        total += x[i]
    }
    fmt.Println(total / 5)
}
이 프로그램은 시험 점수의 평균을 계산한다. 이 프로그램을 실행하면 86.6이 출력될 것이다. 프로그램이 어떻게 동작하는지 살펴보자.

먼저 시험 점수를 담을 길이가 5인 배열을 생성한 다음 각 요소를 점수로 채운다.
다음으로 반복문을 이용해 합계 점수를 계사한다.
마지막으로 합계 점수를 요소의 개수로 나누어 평균을 구한다.
이 프로그램은 동작하지만 Go에서는 이 프로그램을 개선할 수 있는 기능을 제공한다. 먼저 i < 5와 total / 5라고 돼 있는 두 부분을 눈여겨보자. 시험 점수의 개수를 5개에서 6개로 바꿨다고 해보자. 그럼 이 두 부분들을 모두 수정해야 할 것이다. 대신 배열의 길이를 사용하는 편이 더 낫다.


var total float64 = 0
for i := 0; i < len(x); i++ {
    total += x[i]
}
fmt.Println(total / len(x))
직접 프로그램을 이렇게 수정하고 실행해 보자. 그럼 다음과 같은 오류가 나타날 것이다.

$ go run tmp.go
# command-line-arguments
.\tmp.go:19: invalid operation: total / 5
(mismatched types float64 and int)
이 문제는 len(x)와 total의 타입이 서로 다르다는 것이다. total은 float64인 반면 len(x)는 int다. 따라서 len(x)를 float64로 바꿔야 한다.

fmt.Println(total / float64(len(x)))
이것은 형변환(type conversion)의 한 예다. 일반적으로 타입을 변환할 때는 함수처럼 타입명을 사용하면 된다.

이 프로그램에서 수정할 수 있는 또 한 가지 부분은 특별한 형태의 for 루프를 사용하는 것이다.

var total float64 = 0
for i, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))

이 for 루프에서 i는 배열에서의 현재 위치를 나타내고 value는 x[i]와 같다. 아울러 여기서는 순회하고 싶은 변수명 다음에 range라는 키워드를 사용하고 있다.

이 프로그램을 실행하면 다음과 같은 오류가 발생할 것이다.

$ go run tmp.go
# command-line-arguments
.\tmp.go:16: i declared and not used
Go 컴파일러는 사용하지 않은 변수를 생성하지 못하게 한다. 여기서는 반복문 내에서 i를 사용하지 않으므로 다음과 같이 수정해야 한다.

var total float64 = 0
for _, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))
_(언더스코어)는 컴파일러에게 이것이 필요하지 않다고 알려주는 데 사용한다. (이 경우 순회용 변수가 필요하지 않다.)

Go에서는 배열을 생성하는 더 짧은 문법도 제공한다.

x := [5]float64{ 98, 93, 77, 82, 83 }
Go에서 타입을 파악할 수 있기 때문에 더는 타입을 지정할 필요가 없다. 간혹 배열을 이런 식으로 생성하면 한 줄에 맞춰 넣기가 힘들 때도 있으므로 Go에서는 다음과 같은 식으로 나눠 써도 된다.

x := [5]float64{
    98,
    93,
    77,
    82,
    83,
}

여기서 83 다음에 ,가 따라 나오는 것을 눈여겨보자. Go에서는 이렇게 하는 것이 필수이고, 이렇게 하면 특정 줄을 주석으로 처리해 배열의 요소를 손쉽게 제거할 수 있다.

x := [4]float64{
    98,
    93,
    77,
    82,
    // 83,
}
이 예제는 배열과 관련한 큰 문제를 하나 보여준다. 바로 배열의 길이가 고정돼 있다는 것과 배열의 타입명과 관련된 문제다. 마지막 항목을 제거하기 위해 실제로 타입도 변경해야 했다. Go에서는 이 문제의 해법으로 슬라이스라는 또 다른 타입을 사용할 수 있다.

 ㄴ
슬라이스(slice)는 배열의 일부다. 배열과 마찬가지로 슬라이스도 인덱스를 통해 접근할 수 있고 길이가 있다. 하지만 배열과 달리 슬라이스의 길이는 바뀔 수 있다. 다음은 슬라이스의 예다.

var x []float64
슬라이스와 배열의 유일한 차이점은 대괄호 사이에 길이가 없다는 것이다. 이 경우 x는 길이가 0인 상태로 생성된다.

슬라이스를 생성하고 싶다면 내장 함수인 make를 사용하면 된다.

x := make([]float64, 5)
이렇게 하면 기저에 길이가 5인 float64 배열과 연관된 슬라이스가 만들어진다. 슬라이스는 항상 그것과 연관된 배열이 있고, 해당 배열보다 절대로 길어질 수는 없지만 더 작아질 수는 있다. make 함수에는 세 번째 매개변수를 전달할 수도 있다.

x := make([]float64, 5, 10)
10은 이 슬라이스가 가리키는 기저 배열이 점유하는 공간을 나타낸다.

슬라이스

슬라이스를 만드는 또 다른 방법은 [low : high] 수식을 사용하는 것이다.


arr := []float64{1,2,3,4,5}
x := arr[0:5]
low는 슬라이스가 시작되는 인덱스이고, high는 슬라이스가 끝나는 인덱스다(인덱스 자체는 포함하지 않는다). 예를 들어 arr[0:5]는 [1,2,3,4,5]를 반환하는 데 반해 arr[1:4]는 [2,3,4]를 반환한다.

편의를 위해 low나 high를 생략하거나 심지어 low와 high를 모두 생략할 수도 있다. arr[0:]은 arr[0:len(arr)]와 같고 arr[:5]는 arr[0:5]와 같으며, arr[:]은 arr[0:len(arr)]과 같다.

슬라이스 함수
Go에는 append와 copy라는 슬라이스를 사용하는 데 도움이 되는 두 가지 내장 함수가 포함돼 있다. 다음은 append를 사용하는 예제다.

func main() {
    slice1 := []int{1,2,3}
    slice2 := append(slice1, 4, 5)
    fmt.Println(slice1, slice2)
}
이 프로그램을 실행하면 slice1은 [1,2,3]이 되고 slice2는 [1,2,3,4,5]가 된다. append는 기존 슬라이스(첫 번째 인자)를 가져와서 그다음에 이어지는 인자를 모두 거기에 덧붙이는 식으로 새 슬라이스를 생성한다.

다음은 copy를 사용하는 예제다.

func main() {
    slice1 := []int{1,2,3}
    slice2 := make([]int, 2)
    copy(slice2, slice1)
    fmt.Println(slice1, slice2)
}
이 프로그램을 실행하면 slice1은 [1,2,3]이 되고 slice2는 [1,2]가 된다. slice1의 내용은 slice2로 복사되는데, slice2에는 두 요소가 들어갈 만한 공간밖에 없어서 slice1의 첫 두 요소만 복사된다.